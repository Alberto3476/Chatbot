import Navigation from '../../../components/widgets/Navigation'

# State

`state` nos permite mantener un estado en comÃºn entre flujos para compartir informaciÃ³n relevante entre ellos. Esto tambien funciona si usas `goToFlow`.

```js
  const flujoPrincipal = addKeyword(['hola'])
        .addAnswer(
            'Â¿CuÃ¡l es tu nombre?',
            {
                capture: true,
            },
            async (ctx, { flowDynamic, state }) => {
                state.update({ name: ctx.body })
                flowDynamic('Gracias por tu nombre!')
            }
        )
        .addAnswer(
            'Â¿Cual es tu edad?',
            {
                capture: true,
            },
            async (ctx, { flowDynamic, state }) => {
                state.update({ age: ctx.body })
                const myState = state.getMyState()
                await flowDynamic(`Gracias por tu edad! ${myState.name}`)
            }
        )
        .addAnswer('Tus datos son:', null, async (_, { flowDynamic, state }) => {
            const myState = state.getMyState()
            await flowDynamic(`Nombre: ${myState.name} - Edad: ${myState.age}`)
        })
        .addAnswer('ðŸ¤–ðŸ¤– Gracias por tu participaciÃ³n')
```

---

### update

El mÃ©todo `update` nos permite actualizar el estado para compartir informaciÃ³n entre flujos.
**NOTA**: Es importante considerar que se debe pasar un objeto para que pueda ser actualizado en el estado. Si al actualizar encuentra que la propiedad ya existe, se actualizarÃ¡ el valor, de lo contrario se agregarÃ¡ la propiedad al estado.

```js
const flujoPrincipal = addKeyword('Hola')
	.addAnswer('Â¿CÃ³mo te llamas?', { capture: true }, ({ body }, { state }) =>
		state.update({ nombre: body }))
```

---

### getMyState

El mÃ©todo `getMyState` retorna el objeto con las propiedades que hemos actualizado en el estado de la conversaciÃ³n.

```js
const flujoPrincipal = addKeyword)'Hola')
	.addAnswer('Â¿CuÃ¡l es tu nombre?', { capture: true}, ({ body }, { state }) =>
		state.update({ nombre: body }))
	.addAction(async (_, { fowDynamic }) => {
		await flowDynamic(`Mucho gusto ${ state.getMyState().nombre }`)
	})
```

Como se puede observar en el ejemplo, la propiedad `nombre` es la misma que actualizamos con el mÃ©todo `update` del `state`.

---

### clear

El mÃ©todo `clear` nos permite reiniciar el estado a un valor `undefined`.

```js
const flujoPrincipal = addKeyword)'Hola')
	.addAnswer('Â¿CuÃ¡l es tu nombre?', { capture: true}, ({ body }, { state }) =>
		state.update({ nombre: body }))
	.addAction((_, { state }) => state.clear())
```

---

## GlobalState

De igual manera que el `state` anterior, podemos usar `globalState` para tener un estado general de la app (NO es por usuario). Esto es muy Ãºtil si quieres apagar o prender el bot.

```js
    const flowOnOff = addKeyword(['onoff'])
    .addAction(async (_, { flowDynamic, globalState }) => {
        const currentGlobalState = globalState.getMyState();
        if(currentGlobalState.encendido) {
            globalState.update({encendido:false})
        }else{
            globalState.update({encendido:true})
        }
    })
    .addAnswer('ðŸ¤–ðŸ¤– Gracias por tu participacion')

    ...

    const flowWelcome = addKeyword(EVENTS.WELCOME)
    .addAction((_, { endFlow, globalState }) => {
        const currentGlobalState = globalState.getMyState();
        if (!currentGlobalState.encendido) {
            return endFlow();
        }
    })

    ...

  createBot(
    {
      flow: adapterFlow,
      provider: adapterProvider,
      database: adapterDB,
    },
    {
      globalState: {
        encendido: true,
      }
    }
  );
```

---

<Navigation
    pages={[
        { name: 'InstalaciÃ³n', link: '/docs/install' },
        { name: 'Conceptos', link: '/docs/essential' },
    ]}
/>
